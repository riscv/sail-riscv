chapter \<open>Generated by Lem from \<open>string.lem\<close>.\<close>

theory "Lem_string" 

imports
  Main
  "Lem_bool"
  "Lem_basic_classes"
  "Lem_list"

begin 



\<comment> \<open>\<open>open import Bool Basic_classes List\<close>\<close>
\<comment> \<open>\<open>open import {ocaml} `Xstring`\<close>\<close>
\<comment> \<open>\<open>open import {hol} `lemTheory` `stringTheory`\<close>\<close>
\<comment> \<open>\<open>open import {coq} `Coq.Strings.Ascii` `Coq.Strings.String`\<close>\<close>

\<comment> \<open>\<open> ------------------------------------------- \<close>\<close>
\<comment> \<open>\<open> translations between strings and char lists \<close>\<close>
\<comment> \<open>\<open> ------------------------------------------- \<close>\<close>

\<comment> \<open>\<open>val toCharList : string -> list char\<close>\<close>

\<comment> \<open>\<open>val toString : list char -> string\<close>\<close>


\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> generating strings      \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open>val makeString : nat -> char -> string\<close>\<close>
\<comment> \<open>\<open>let makeString len c=  toString (replicate len c)\<close>\<close>

\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> length                  \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open>val stringLength : string -> nat\<close>\<close>

\<comment> \<open>\<open> ----------------------- \<close>\<close>
\<comment> \<open>\<open> string concatenation    \<close>\<close>
\<comment> \<open>\<open> ----------------------- \<close>\<close>

\<comment> \<open>\<open>val ^ [stringAppend] : string -> string -> string\<close>\<close>


\<comment> \<open>\<open> ----------------------------\<close>\<close>
\<comment> \<open>\<open> setting up pattern matching \<close>\<close>
\<comment> \<open>\<open> --------------------------- \<close>\<close>

\<comment> \<open>\<open>val string_case : forall 'a. string -> 'a -> (char -> string -> 'a) -> 'a\<close>\<close>

\<comment> \<open>\<open>let string_case s c_empty c_cons=
   match (toCharList s) with
    | [] -> c_empty
    | c :: cs -> c_cons c (toString cs)
  end\<close>\<close>

\<comment> \<open>\<open>val empty_string : string\<close>\<close>

\<comment> \<open>\<open>val cons_string : char -> string -> string\<close>\<close>

\<comment> \<open>\<open>val concat : string -> list string -> string\<close>\<close>
function (sequential,domintros)  concat  :: \<open> string \<Rightarrow>(string)list \<Rightarrow> string \<close>  where 
     \<open> concat sep ([]) = ( (''''))\<close> 
  for  sep  :: " string "
|\<open> concat sep (s # ss') = (
      (case  ss' of
        [] => s
      | _ => s @ (sep @ concat sep ss')
      ))\<close> 
  for  sep  :: " string " 
  and  ss'  :: "(string)list " 
  and  s  :: " string " 
by pat_completeness auto

end
