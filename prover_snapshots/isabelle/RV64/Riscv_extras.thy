chapter \<open>Generated by Lem from \<open>handwritten_support/0.11/riscv_extras.lem\<close>.\<close>

theory "Riscv_extras" 

imports
  Main
  "LEM.Lem_pervasives"
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"

begin 

\<comment> \<open>\<open>open import Pervasives\<close>\<close>
\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_instr_kinds\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators_mwords\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt\<close>\<close>

type_synonym 'a bitvector =" ( 'a::len)Word.word "

definition MEM_fence_rw_rw  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_rw_rw _ = ( barrier (Barrier_RISCV_rw_rw () ))\<close>

definition MEM_fence_r_rw  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_r_rw  _ = ( barrier (Barrier_RISCV_r_rw () ))\<close>

definition MEM_fence_r_r  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_r_r   _ = ( barrier (Barrier_RISCV_r_r () ))\<close>

definition MEM_fence_rw_w  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_rw_w  _ = ( barrier (Barrier_RISCV_rw_w () ))\<close>

definition MEM_fence_w_w  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_w_w   _ = ( barrier (Barrier_RISCV_w_w () ))\<close>

definition MEM_fence_w_rw  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_w_rw  _ = ( barrier (Barrier_RISCV_w_rw () ))\<close>

definition MEM_fence_rw_r  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_rw_r  _ = ( barrier (Barrier_RISCV_rw_r () ))\<close>

definition MEM_fence_r_w  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_r_w   _ = ( barrier (Barrier_RISCV_r_w () ))\<close>

definition MEM_fence_w_r  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_w_r   _ = ( barrier (Barrier_RISCV_w_r () ))\<close>

definition MEM_fence_tso  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_tso   _ = ( barrier (Barrier_RISCV_tso () ))\<close>

definition MEM_fence_i  :: \<open> unit \<Rightarrow>('b,(unit),'a)monad \<close>  where 
     \<open> MEM_fence_i     _ = ( barrier (Barrier_RISCV_i () ))\<close>


\<comment> \<open>\<open>val MEMea                            : forall 'rv 'a 'e. Size 'a => bitvector 'a -> integer -> monad 'rv unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMea_release                    : forall 'rv 'a 'e. Size 'a => bitvector 'a -> integer -> monad 'rv unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMea_strong_release             : forall 'rv 'a 'e. Size 'a => bitvector 'a -> integer -> monad 'rv unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMea_conditional                : forall 'rv 'a 'e. Size 'a => bitvector 'a -> integer -> monad 'rv unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMea_conditional_release        : forall 'rv 'a 'e. Size 'a => bitvector 'a -> integer -> monad 'rv unit 'e\<close>\<close>
\<comment> \<open>\<open>val MEMea_conditional_strong_release : forall 'rv 'a 'e. Size 'a => bitvector 'a -> integer -> monad 'rv unit 'e\<close>\<close>

definition MEMea  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(unit),'e)monad \<close>                       where 
     \<open> MEMea addr size1                      = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain ()  addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "

definition MEMea_release  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(unit),'e)monad \<close>               where 
     \<open> MEMea_release addr size1              = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_release ()  addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "

definition MEMea_strong_release  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(unit),'e)monad \<close>        where 
     \<open> MEMea_strong_release addr size1       = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_strong_release ()  addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "

definition MEMea_conditional  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(unit),'e)monad \<close>           where 
     \<open> MEMea_conditional addr size1          = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_conditional ()  addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "

definition MEMea_conditional_release  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(unit),'e)monad \<close>   where 
     \<open> MEMea_conditional_release addr size1  = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_conditional_release ()  addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "

definition MEMea_conditional_strong_release  :: \<open>('a::len)Word.word \<Rightarrow> int \<Rightarrow>('rv,(unit),'e)monad \<close> 
                                          where 
     \<open> MEMea_conditional_strong_release addr size1
                                          = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_conditional_strong_release ()  addr size1 )\<close> 
  for  addr  :: "('a::len)Word.word " 
  and  size1  :: " int "


\<comment> \<open>\<open>val MEMr                         : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> monad 'rv (bitvector 'b) 'e\<close>\<close>
\<comment> \<open>\<open>val MEMr_acquire                 : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> monad 'rv (bitvector 'b) 'e\<close>\<close>
\<comment> \<open>\<open>val MEMr_strong_acquire          : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> monad 'rv (bitvector 'b) 'e\<close>\<close>
\<comment> \<open>\<open>val MEMr_reserved                : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> monad 'rv (bitvector 'b) 'e\<close>\<close>
\<comment> \<open>\<open>val MEMr_reserved_acquire        : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> monad 'rv (bitvector 'b) 'e\<close>\<close>
\<comment> \<open>\<open>val MEMr_reserved_strong_acquire : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> monad 'rv (bitvector 'b) 'e\<close>\<close>

definition MEMr  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('b::len)Word.word),'e)monad \<close>                          where 
     \<open> MEMr addrsize size1 hexRAM addr                         = ( read_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMr_acquire  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('b::len)Word.word),'e)monad \<close>                  where 
     \<open> MEMr_acquire addrsize size1 hexRAM addr                 = ( read_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_RISCV_acquire addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMr_strong_acquire  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('b::len)Word.word),'e)monad \<close>           where 
     \<open> MEMr_strong_acquire addrsize size1 hexRAM addr          = ( read_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_RISCV_strong_acquire addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMr_reserved  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('b::len)Word.word),'e)monad \<close>                 where 
     \<open> MEMr_reserved addrsize size1 hexRAM addr                = ( read_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_RISCV_reserved addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMr_reserved_acquire  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('b::len)Word.word),'e)monad \<close>         where 
     \<open> MEMr_reserved_acquire addrsize size1 hexRAM addr        = ( read_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_RISCV_reserved_acquire addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMr_reserved_strong_acquire  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('rv,(('b::len)Word.word),'e)monad \<close>  where 
     \<open> MEMr_reserved_strong_acquire addrsize size1 hexRAM addr = ( read_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_RISCV_reserved_strong_acquire addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "


\<comment> \<open>\<open>val MEMw                            : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> bitvector 'b -> monad 'rv bool 'e\<close>\<close>
\<comment> \<open>\<open>val MEMw_release                    : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> bitvector 'b -> monad 'rv bool 'e\<close>\<close>
\<comment> \<open>\<open>val MEMw_strong_release             : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> bitvector 'b -> monad 'rv bool 'e\<close>\<close>
\<comment> \<open>\<open>val MEMw_conditional                : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> bitvector 'b -> monad 'rv bool 'e\<close>\<close>
\<comment> \<open>\<open>val MEMw_conditional_release        : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> bitvector 'b -> monad 'rv bool 'e\<close>\<close>
\<comment> \<open>\<open>val MEMw_conditional_strong_release : forall 'rv 'a 'b 'e. Size 'a, Size 'b => integer -> integer -> bitvector 'a -> bitvector 'a -> bitvector 'b -> monad 'rv bool 'e\<close>\<close>

definition MEMw  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('rv,(bool),'e)monad \<close>                             where 
     \<open> MEMw addrsize size1 hexRAM addr                            = ( write_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMw_release  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('rv,(bool),'e)monad \<close>                     where 
     \<open> MEMw_release addrsize size1 hexRAM addr                    = ( write_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_release addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMw_strong_release  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('rv,(bool),'e)monad \<close>              where 
     \<open> MEMw_strong_release addrsize size1 hexRAM addr             = ( write_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_strong_release addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMw_conditional  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('rv,(bool),'e)monad \<close>                 where 
     \<open> MEMw_conditional addrsize size1 hexRAM addr                = ( write_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_conditional addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMw_conditional_release  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('rv,(bool),'e)monad \<close>         where 
     \<open> MEMw_conditional_release addrsize size1 hexRAM addr        = ( write_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_conditional_release addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "

definition MEMw_conditional_strong_release  :: \<open> int \<Rightarrow> int \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('rv,(bool),'e)monad \<close>  where 
     \<open> MEMw_conditional_strong_release addrsize size1 hexRAM addr = ( write_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_RISCV_conditional_strong_release addrsize addr size1 )\<close> 
  for  addrsize  :: " int " 
  and  size1  :: " int " 
  and  hexRAM  :: "('a::len)Word.word " 
  and  addr  :: "('a::len)Word.word "


\<comment> \<open>\<open>val load_reservation : forall 'a. Size 'a => bitvector 'a -> unit\<close>\<close>
definition load_reservation  :: \<open>('a::len)Word.word \<Rightarrow> unit \<close>  where 
     \<open> load_reservation addr = ( ()  )\<close> 
  for  addr  :: "('a::len)Word.word "


definition speculate_conditional_success  :: \<open> unit \<Rightarrow>('b,(bool),'a)monad \<close>  where 
     \<open> speculate_conditional_success _ = ( excl_result ()  )\<close>


definition match_reservation  :: \<open> 'a \<Rightarrow> bool \<close>  where 
     \<open> match_reservation _ = ( True )\<close>

definition cancel_reservation  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> cancel_reservation _ = ( ()  )\<close>


\<comment> \<open>\<open>val sys_enable_writable_misa : unit -> bool\<close>\<close>
definition sys_enable_writable_misa  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> sys_enable_writable_misa _ = ( True )\<close>


\<comment> \<open>\<open>val sys_enable_rvc : unit -> bool\<close>\<close>
definition sys_enable_rvc  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> sys_enable_rvc _ = ( True )\<close>


\<comment> \<open>\<open>val sys_enable_next : unit -> bool\<close>\<close>
definition sys_enable_next  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> sys_enable_next _ = ( True )\<close>


\<comment> \<open>\<open>val sys_enable_fdext : unit -> bool\<close>\<close>
definition sys_enable_fdext  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> sys_enable_fdext _ = ( True )\<close>


\<comment> \<open>\<open>val plat_ram_base : forall 'a. Size 'a => unit -> bitvector 'a\<close>\<close>
definition plat_ram_base  :: \<open> unit \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> plat_ram_base _ = ( Word.word_of_int(( 0 :: int)))\<close>


\<comment> \<open>\<open>val plat_ram_size : forall 'a. Size 'a => unit -> bitvector 'a\<close>\<close>
definition plat_ram_size  :: \<open> unit \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> plat_ram_size _ = ( Word.word_of_int(( 0 :: int)))\<close>


\<comment> \<open>\<open>val plat_rom_base : forall 'a. Size 'a => unit -> bitvector 'a\<close>\<close>
definition plat_rom_base  :: \<open> unit \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> plat_rom_base _ = ( Word.word_of_int(( 0 :: int)))\<close>


\<comment> \<open>\<open>val plat_rom_size : forall 'a. Size 'a => unit -> bitvector 'a\<close>\<close>
definition plat_rom_size  :: \<open> unit \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> plat_rom_size _ = ( Word.word_of_int(( 0 :: int)))\<close>


\<comment> \<open>\<open>val plat_clint_base : forall 'a. Size 'a => unit -> bitvector 'a\<close>\<close>
definition plat_clint_base  :: \<open> unit \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> plat_clint_base _ = ( Word.word_of_int(( 0 :: int)))\<close>


\<comment> \<open>\<open>val plat_clint_size : forall 'a. Size 'a => unit -> bitvector 'a\<close>\<close>
definition plat_clint_size  :: \<open> unit \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> plat_clint_size _ = ( Word.word_of_int(( 0 :: int)))\<close>


\<comment> \<open>\<open>val plat_enable_dirty_update : unit -> bool\<close>\<close>
definition plat_enable_dirty_update  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> plat_enable_dirty_update _ = ( False )\<close>


\<comment> \<open>\<open>val plat_enable_misaligned_access : unit -> bool\<close>\<close>
definition plat_enable_misaligned_access  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> plat_enable_misaligned_access _ = ( False )\<close>


\<comment> \<open>\<open>val plat_enable_pmp : unit -> bool\<close>\<close>
definition plat_enable_pmp  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> plat_enable_pmp _ = ( False )\<close>


\<comment> \<open>\<open>val plat_mtval_has_illegal_inst_bits : unit -> bool\<close>\<close>
definition plat_mtval_has_illegal_inst_bits  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> plat_mtval_has_illegal_inst_bits _ = ( False )\<close>


\<comment> \<open>\<open>val plat_insns_per_tick : unit -> integer\<close>\<close>
definition plat_insns_per_tick  :: \<open> unit \<Rightarrow> int \<close>  where 
     \<open> plat_insns_per_tick _ = (( 1 :: int))\<close>


\<comment> \<open>\<open>val plat_htif_tohost : forall 'a. Size 'a => unit -> bitvector 'a\<close>\<close>
definition plat_htif_tohost  :: \<open> unit \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> plat_htif_tohost _ = ( Word.word_of_int(( 0 :: int)))\<close>


\<comment> \<open>\<open>val plat_term_write : forall 'a. Size 'a => bitvector 'a -> unit\<close>\<close>
definition plat_term_write  :: \<open>('a::len)Word.word \<Rightarrow> unit \<close>  where 
     \<open> plat_term_write _ = ( ()  )\<close>


\<comment> \<open>\<open>val plat_term_read : forall 'a. Size 'a => unit -> bitvector 'a\<close>\<close>
definition plat_term_read  :: \<open> unit \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> plat_term_read _ = ( Word.word_of_int(( 0 :: int)))\<close>


\<comment> \<open>\<open>val shift_bits_right : forall 'a 'b. Size 'a, Size 'b => bitvector 'a -> bitvector 'b -> bitvector 'a\<close>\<close>
definition shift_bits_right  :: \<open>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> shift_bits_right v m = ( shiftr v (Word.uint m))\<close> 
  for  v  :: "('a::len)Word.word " 
  and  m  :: "('b::len)Word.word "

\<comment> \<open>\<open>val shift_bits_left : forall 'a 'b. Size 'a, Size 'b => bitvector 'a -> bitvector 'b -> bitvector 'a\<close>\<close>
definition shift_bits_left  :: \<open>('a::len)Word.word \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word \<close>  where 
     \<open> shift_bits_left v m = ( shiftl v (Word.uint m))\<close> 
  for  v  :: "('a::len)Word.word " 
  and  m  :: "('b::len)Word.word "


\<comment> \<open>\<open>val print_string : string -> string -> unit\<close>\<close>
definition print_string  :: \<open> string \<Rightarrow> string \<Rightarrow> unit \<close>  where 
     \<open> print_string msg s = ( ()  )\<close> 
  for  msg  :: " string " 
  and  s  :: " string "
 \<comment> \<open>\<open> print_endline (msg ^ s) \<close>\<close>

\<comment> \<open>\<open>val prerr_string : string -> string -> unit\<close>\<close>
definition prerr_string  :: \<open> string \<Rightarrow> string \<Rightarrow> unit \<close>  where 
     \<open> prerr_string msg s = ( prerr_endline (msg @ s))\<close> 
  for  msg  :: " string " 
  and  s  :: " string "


\<comment> \<open>\<open>val prerr_bits : forall 'a. Size 'a => string -> bitvector 'a -> unit\<close>\<close>
definition prerr_bits  :: \<open> string \<Rightarrow>('a::len)Word.word \<Rightarrow> unit \<close>  where 
     \<open> prerr_bits msg bs = ( prerr_endline (msg @ (show_bitlist (List.map bitU_of_bool (Word.to_bl bs)))))\<close> 
  for  msg  :: " string " 
  and  bs  :: "('a::len)Word.word "


\<comment> \<open>\<open>val print_bits : forall 'a. Size 'a => string -> bitvector 'a -> unit\<close>\<close>
definition print_bits0  :: \<open> string \<Rightarrow>('a::len)Word.word \<Rightarrow> unit \<close>  where 
     \<open> print_bits0 msg bs = ( ()  )\<close> 
  for  msg  :: " string " 
  and  bs  :: "('a::len)Word.word "
 \<comment> \<open>\<open> print_endline (msg ^ (show_bitlist (bits_of bs))) \<close>\<close>

\<comment> \<open>\<open>val print_dbg : string -> unit\<close>\<close>
definition print_dbg  :: \<open> string \<Rightarrow> unit \<close>  where 
     \<open> print_dbg msg = ( ()  )\<close> 
  for  msg  :: " string "

end
