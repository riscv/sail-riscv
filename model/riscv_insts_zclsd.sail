/*=======================================================================================*/
/*  This Sail RISC-V architecture model, comprising all files and                        */
/*  directories except where otherwise noted is subject the BSD                          */
/*  two-clause license in https://github.com/riscv/sail-riscv/blob/master/LICENCE.       */
/*                                                                                       */
/*  SPDX-License-Identifier: BSD-2-Clause                                                */
/*  This file is generated by make_td tool as part of Tristan Project                    */
/*=======================================================================================*/


enum clause extension = Ext_Zclsd
function clause extensionEnabled(Ext_Zclsd) = xlen == 32 & sys_enable_zclsd() & extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd)

union clause ast = ZCLSD_C_LD : (bits(5), cregidx, cregidx)

mapping clause encdec_compressed = ZCLSD_C_LD(i7_6 @ i5_3, rs1c_p, rdc_p)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32
<-> 0b011 @ i5_3 : bits(3) @ encdec_creg(rs1c_p) @ i7_6 : bits(2) @ encdec_creg(rdc_p) @ 0b00
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32

function clause execute(ZCLSD_C_LD(imm, rs1c_p, rdc_p)) = {
	let offset : xlenbits = zero_extend(imm@ 0b000);
	let rs1c_p_idx = creg2reg_idx(rs1c_p);
	let rdc_p_idx = creg2reg_idx(rdc_p);
	let vaddr = X(rs1c_p_idx) + offset;
	if xlen == 32 then
	if check_misaligned(virtaddr(vaddr), DOUBLE)
	then {handle_mem_exception(virtaddr(vaddr), E_Load_Addr_Align()); RETIRE_FAIL}
	else match translateAddr(virtaddr(vaddr), Read(Data)) {
	TR_Failure(e, _) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
	TR_Address(paddr, _) =>
		match mem_read(Read(Data), paddr, 4, false, false, false) {
		Ok(result) => {
			match translateAddr(virtaddr(vaddr+4), Read(Data)) {
			TR_Failure(e, _) => {handle_mem_exception(virtaddr(vaddr+4), e); RETIRE_FAIL},
			TR_Address(paddr_4, _) =>
				match mem_read(Read(Data), paddr_4, 4, false, false, false) {
				Ok(result1) => {
					X(rdc_p_idx) = sign_extend(result);
					X(regidx_offset(rdc_p_idx, to_bits(5, 1))) = sign_extend(result1);
					RETIRE_SUCCESS
				},
				Err(e) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
			}
		}
	},
	Err(e) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
	},
}
	else RETIRE_FAIL
}

mapping clause assembly = ZCLSD_C_LD(imm, rs1c_p, rdc_p)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32
<-> "c.ld" ^ spc() ^ creg_name(rs1c_p) ^ sep() ^ creg_name(rdc_p) ^ sep() ^ hex_bits_8(imm @ 0b000)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32

union clause ast = ZCLSD_C_LDSP : (bits(6), regidx)

mapping clause encdec_compressed = ZCLSD_C_LDSP(i8_6 @ i5_5 @ i4_3, rx)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32
<-> 0b011 @ i5_5 : bits(1) @ encdec_reg(rx) @ i4_3 : bits(2) @ i8_6 : bits(3) @ 0b10
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32

function clause execute(ZCLSD_C_LDSP(imm, rx)) = {
	let offset : xlenbits = zero_extend(imm@ 0b000);
	let vaddr = X(sp) + offset;
	if xlen == 32 then
	if check_misaligned(virtaddr(vaddr), DOUBLE)
	then {handle_mem_exception(virtaddr(vaddr), E_Load_Addr_Align()); RETIRE_FAIL}
	else match translateAddr(virtaddr(vaddr), Read(Data)) {
	TR_Failure(e, _) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
	TR_Address(paddr, _) =>
		match mem_read(Read(Data), paddr, 4, false, false, false) {
		Ok(result) => {
			match translateAddr(virtaddr(vaddr+4), Read(Data)) {
			TR_Failure(e, _) => {handle_mem_exception(virtaddr(vaddr+4), e); RETIRE_FAIL},
			TR_Address(paddr_4, _) =>
				match mem_read(Read(Data), paddr_4, 4, false, false, false) {
				Ok(result1) => {
					X(rx) = sign_extend(result);
					X(regidx_offset(rx, to_bits(5, 1))) = sign_extend(result1);
					RETIRE_SUCCESS
				},
				Err(e) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
			}
		}
	},
	Err(e) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
	},
}
	else RETIRE_FAIL
}

mapping clause assembly = ZCLSD_C_LDSP(imm, rx)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32
<-> "c.ldsp" ^ spc() ^ reg_name(rx) ^ sep() ^ hex_bits_9(imm @ 0b000)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32

union clause ast = ZCLSD_C_SD : (bits(5), cregidx, cregidx)

mapping clause encdec_compressed = ZCLSD_C_SD(i7_6 @ i5_3, rs1c_p, rs2c_p)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32
<-> 0b111 @ i5_3 : bits(3) @ encdec_creg(rs1c_p) @ i7_6 : bits(2) @ encdec_creg(rs2c_p) @ 0b00
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32

function clause execute(ZCLSD_C_SD(imm, rs1c_p, rs2c_p)) = {
	let offset : xlenbits = zero_extend(imm@ 0b000);
	let rs1c_p_idx = creg2reg_idx(rs1c_p);
	let rs2c_p_idx = creg2reg_idx(rs2c_p);
	let vaddr = X(rs1c_p_idx) + offset;
	if xlen == 32 then
	if check_misaligned(virtaddr(vaddr), DOUBLE)
	then {handle_mem_exception(virtaddr(vaddr), E_SAMO_Addr_Align()); RETIRE_FAIL}
	else match translateAddr(virtaddr(vaddr), Read(Data)) {
	TR_Failure(e, _) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
	TR_Address(paddr, _) =>
		match mem_write_ea(paddr, 4, false, false, false) {
		Ok(_) => {
			let result : MemoryOpResult(bool) = mem_write_value(paddr, 4, X(rs2c_p_idx), false, false, false) in
			match result {
				Ok(true) =>{
				match translateAddr(virtaddr(vaddr+4), Write(Data)) {
				TR_Failure(e, _) => {handle_mem_exception(virtaddr(vaddr+4), e); RETIRE_FAIL},
				TR_Address(paddr_4, _) =>
					match mem_write_ea(paddr_4, 4, false, false, false) {
						Ok(_) => {
							let result1 : MemoryOpResult(bool) = mem_write_value(paddr_4, 4, X(regidx_offset(rs2c_p_idx, to_bits(5,1))), false, false, false) in
							match result1 {
								Ok(true) => {RETIRE_SUCCESS},
								Ok(false) => {internal_error(__FILE__, __LINE__, "c.sd failed")},
								Err(e) => {handle_mem_exception(virtaddr(vaddr+4), e); RETIRE_FAIL},
							}
					},
				Err(e) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
				}
			}
			},
			Ok(false) => {internal_error(__FILE__, __LINE__, "c.sd failed")},
			Err(e) => {handle_mem_exception(virtaddr(vaddr+4), e); RETIRE_FAIL},
			}
		},
		Err(e) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
		},
	}
	else RETIRE_FAIL
}

mapping clause assembly = ZCLSD_C_SD(imm, rs1c_p, rs2c_p)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32
<-> "c.sd" ^ spc() ^ creg_name(rs1c_p) ^ sep() ^ creg_name(rs2c_p) ^ sep() ^ hex_bits_8(imm @ 0b000)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32

union clause ast = ZCLSD_C_SDSP : (bits(6), regidx)

mapping clause encdec_compressed = ZCLSD_C_SDSP(i8_6 @ i5_3, rs2c)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32
<-> 0b111 @ i5_3 : bits(3) @ i8_6 : bits(3) @ encdec_reg(rs2c) @ 0b10
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32

function clause execute(ZCLSD_C_SDSP(imm, rs2c)) = {
	let offset : xlenbits = zero_extend(imm@ 0b000);
	let vaddr = X(sp) + offset;
	if xlen == 32 then
	if check_misaligned(virtaddr(vaddr), DOUBLE)
	then {handle_mem_exception(virtaddr(vaddr), E_SAMO_Addr_Align()); RETIRE_FAIL}
	else match translateAddr(virtaddr(vaddr), Read(Data)) {
	TR_Failure(e, _) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
	TR_Address(paddr, _) =>
		match mem_write_ea(paddr, 4, false, false, false) {
		Ok(_) => {
			let result : MemoryOpResult(bool) = mem_write_value(paddr, 4, X(rs2c), false, false, false) in
			match result {
				Ok(true) =>{
				match translateAddr(virtaddr(vaddr+4), Write(Data)) {
				TR_Failure(e, _) => {handle_mem_exception(virtaddr(vaddr+4), e); RETIRE_FAIL},
				TR_Address(paddr_4, _) =>
					match mem_write_ea(paddr_4, 4, false, false, false) {
						Ok(_) => {
							let value : xlenbits = if  encdec_reg(rs2c) == zeros() then zeros() else X(regidx_offset(rs2c, to_bits(5,1))) in
							let result1 : MemoryOpResult(bool) = mem_write_value(paddr_4, 4, value, false, false, false) in
							match result1 {
								Ok(true) => {RETIRE_SUCCESS},
								Ok(false) => {internal_error(__FILE__, __LINE__, "c.sdsp failed")},
								Err(e) => {handle_mem_exception(virtaddr(vaddr+4), e); RETIRE_FAIL},
							}
					},
				Err(e) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
				}
			}
			},
			Ok(false) => {internal_error(__FILE__, __LINE__, "c.sdsp failed")},
			Err(e) => {handle_mem_exception(virtaddr(vaddr+4), e); RETIRE_FAIL},
			}
		},
		Err(e) => {handle_mem_exception(virtaddr(vaddr), e); RETIRE_FAIL},
		},
	}
	else RETIRE_FAIL
}

mapping clause assembly = ZCLSD_C_SDSP(imm, rs2c)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32
<-> "c.sdsp" ^ spc() ^ reg_name(rs2c) ^ sep() ^ hex_bits_9(imm @ 0b000)
	if extensionEnabled(Ext_Zca) & extensionEnabled(Ext_Zilsd) & extensionEnabled(Ext_Zclsd) & xlen == 32

